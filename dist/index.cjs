"use strict";Object.defineProperty(exports,"__esModule",{value:!0});var e=require("fs"),r=require("path"),t=require("process"),i=require("child_process");let n=null;const s="production"===t.env.NODE_ENV;function c(){const e=t.cwd(),i=r.join(e,"logProLog"),n=`temp_${t.pid}`;return[i,r.join(i,n)]}function o(){if(s)return;const[o,a]=c();n=a,e.existsSync(o)||e.mkdirSync(o,{recursive:!0});const l=r.dirname(a);e.existsSync(l)&&e.readdirSync(l).forEach(n=>{if(n.startsWith("temp_")&&e.statSync(r.join(l,n)).isDirectory())try{const s=n.split("_")[1];if(!function(e){try{return"win32"===t.platform?(i.execSync(`tasklist /FI "PID eq ${e}" /NH`),!0):(t.kill(e,0),!0)}catch(e){return!1}}(parseInt(s))){const t=r.join(l,n);e.rmSync(t,{recursive:!0,force:!0})}}catch(e){console.error(`清理旧临时目录时出错: ${e.message}`)}}),e.existsSync(a)||e.mkdirSync(a,{recursive:!0})}function a(t,i={}){let l=i.filename||"default.txt";const y=void 0===i.clear_on_restart||i.clear_on_restart,u=i.show_timestamp||!1,S=void 0!==i.line_breaks?i.line_breaks:1,f=i.folder||null,d=void 0===i.forceWrite||i.forceWrite;if(s)return;null===n&&o();const[_,p]=c();let g,m,h;if(l.includes(".")||(l=`${l}.txt`),y?(g=p,f&&(g=r.join(g,f)),m=r.join(g,l)):(g=_,l.startsWith("persistent_")||(l=`persistent_${l}`),m=r.join(g,l)),e.existsSync(g)||e.mkdirSync(g,{recursive:!0}),"object"==typeof t)try{h=JSON.stringify(t,null,2)}catch{h=String(t)}else h=String(t);let x="";if(u){x+=`[${(new Date).toISOString().replace("T"," ").substring(0,23)}]\n`}x+=h,x+="\n".repeat(S+1);let v="a";y&&(!d&&e.existsSync(m)&&a._initialized_files||(v="w",a._initialized_files||(a._initialized_files=new Set),a._initialized_files.add(m))),e.writeFileSync(m,x,{encoding:"utf-8",flag:v})}function l(t,i){!s&&e.existsSync(t)&&(e.existsSync(i)||e.mkdirSync(i,{recursive:!0}),e.existsSync(i)&&e.readdirSync(i).forEach(t=>{if(t.startsWith("persistent_")||t.startsWith("temp_"))return;const n=r.join(i,t);try{e.statSync(n).isFile()?e.unlinkSync(n):e.statSync(n).isDirectory()&&e.rmSync(n,{recursive:!0,force:!0})}catch(e){console.error(`删除目标目录文件/文件夹 ${n} 时出错: ${e.message}`)}}),e.readdirSync(t).forEach(n=>{const s=r.join(t,n),c=r.join(i,n);e.statSync(s).isFile()?(e.existsSync(c)&&e.unlinkSync(c),e.renameSync(s,c)):e.statSync(s).isDirectory()&&l(s,c)}))}function y(){if(s)return;if(null===n)return;const[t,i]=c();try{o=t,!s&&e.existsSync(o)&&e.readdirSync(o).forEach(t=>{if(t.startsWith("temp_")||t.startsWith("persistent_"))return;const i=r.join(o,t);try{e.statSync(i).isFile()&&e.unlinkSync(i)}catch(e){console.error(`删除文件 ${i} 时出错: ${e.message}`)}}),l(i,t),e.existsSync(i)&&e.rmSync(i,{recursive:!0,force:!0})}catch(e){console.error(`执行清理操作时出错: ${e.message}`)}var o}function u(t=!1){if(s)return;const[i]=c();if(e.existsSync(i))try{t?(e.rmSync(i,{recursive:!0,force:!0}),e.mkdirSync(i,{recursive:!0})):e.readdirSync(i).forEach(t=>{if(t.startsWith("persistent_"))return;const n=r.join(i,t);try{e.statSync(n).isFile()?e.unlinkSync(n):e.statSync(n).isDirectory()&&e.rmSync(n,{recursive:!0,force:!0})}catch(e){console.error(`清空logProLog目录时出错: ${e.message}`)}})}catch(e){console.error(`清空logProLog目录时出错: ${e.message}`)}}s||(t.on("exit",y),["SIGINT","SIGTERM","SIGQUIT"].forEach(e=>{t.on(e,()=>{y(),t.exit(0)})})),s||o();var S={logPro:a,clearLogProLogs:u,_initialize_log_dirs:o,_cleanup:y};exports._cleanup=y,exports._initialize_log_dirs=o,exports.clearLogProLogs=u,exports.default=S,exports.logPro=a;
//# sourceMappingURL=index.cjs.map
