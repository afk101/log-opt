{"version":3,"file":"index.cjs","sources":["../src/index.esm.js"],"sourcesContent":["// ES模块入口文件 - 将CommonJS模块转换为ES模块导出\nimport fs from 'fs';\nimport path from 'path';\nimport process from 'process';\nimport { execSync } from 'child_process';\n\n// 定义全局变量\nlet _temp_dir = null;\n// 检查是否为生产环境\nconst _is_production = process.env.NODE_ENV === \"production\";\n\n/**\n * 获取日志主目录和临时目录的路径\n * @returns {Array} 元组 [主目录路径, 临时目录路径]\n */\nfunction _get_log_dirs() {\n  // 主目录路径\n  const root_dir = process.cwd();\n  const main_log_dir = path.join(root_dir, \"logProLog\");\n\n  // 临时目录路径（使用进程ID确保多进程安全）\n  const temp_dir_name = `temp_${process.pid}`;\n  const temp_log_dir = path.join(main_log_dir, temp_dir_name);\n\n  return [main_log_dir, temp_log_dir];\n}\n\n/**\n * 检查进程是否存在\n * @param {number} pid 进程ID\n * @returns {boolean} 进程是否存在\n */\nfunction _pid_exists(pid) {\n  try {\n    // 在不同操作系统上检查进程是否存在\n    if (process.platform === 'win32') {\n      // Windows\n      execSync(`tasklist /FI \"PID eq ${pid}\" /NH`);\n      return true;\n    } else {\n      // Linux/Mac\n      process.kill(pid, 0);\n      return true;\n    }\n  } catch (e) {\n    return false;\n  }\n}\n\n/**\n * 初始化日志目录，如果发现旧的临时目录则进行清理\n */\nfunction _initialize_log_dirs() {\n  // 如果是生产环境，不执行任何操作\n  if (_is_production) {\n    return;\n  }\n\n  const [main_log_dir, temp_log_dir] = _get_log_dirs();\n  _temp_dir = temp_log_dir;\n\n  // 创建主日志目录（如果不存在）\n  if (!fs.existsSync(main_log_dir)) {\n    fs.mkdirSync(main_log_dir, { recursive: true });\n  }\n\n  // 检查是否存在旧的临时目录（可能是由于上次程序异常退出导致）\n  const temp_parent_dir = path.dirname(temp_log_dir);\n  if (fs.existsSync(temp_parent_dir)) {\n    fs.readdirSync(temp_parent_dir).forEach(item => {\n      // 只处理temp_开头的目录\n      if (item.startsWith(\"temp_\") && fs.statSync(path.join(temp_parent_dir, item)).isDirectory()) {\n        try {\n          // 从目录名提取进程ID\n          const pid_str = item.split('_')[1];\n          const pid = parseInt(pid_str);\n          \n          // 检查进程是否仍在运行\n          if (!_pid_exists(pid)) {\n            // 进程不存在，可以安全删除临时目录\n            const old_temp_dir = path.join(temp_parent_dir, item);\n            fs.rmSync(old_temp_dir, { recursive: true, force: true });\n          }\n        } catch (e) {\n          // 目录名格式不正确或其他错误，不处理\n          console.error(`清理旧临时目录时出错: ${e.message}`);\n        }\n      }\n    });\n  }\n\n  // 创建新的临时目录\n  if (!fs.existsSync(temp_log_dir)) {\n    fs.mkdirSync(temp_log_dir, { recursive: true });\n  }\n}\n\n/**\n * 将内容写入到根目录的logProLog文件夹下的指定文件中，支持多种数据类型的输出。\n * 在生产环境中，此函数不执行任何操作。\n *\n * @param {any} content 要输出的内容，可以是任意类型（字符串、对象、数组等）\n * @param {Object} [options] 配置选项\n * @param {string} [options.filename=\"default.txt\"] 输出文件名，支持各种扩展名如.txt、.json、.js等。如果没有提供后缀，将自动添加.txt\n * @param {boolean} [options.clear_on_restart=true] 是否在服务重启时清空输出文件\n * @param {boolean} [options.show_timestamp=false] 是否显示时间戳\n * @param {number} [options.line_breaks=1] 每条记录之间的空行数，默认为1（即一条记录后空一行）\n * @param {string|null} [options.folder=null] 子文件夹路径，例如'block'或'block/text'\n * @param {boolean} [options.forceWrite=true] 是否强制使用写入模式（覆盖已有内容）\n */\nfunction logPro(content, options = {}) {\n  // 处理配置参数\n  let filename = options.filename || \"default.txt\";\n  const clear_on_restart = options.clear_on_restart !== undefined ? options.clear_on_restart : true;\n  const show_timestamp = options.show_timestamp || false;\n  const line_breaks = options.line_breaks !== undefined ? options.line_breaks : 1;\n  const folder = options.folder || null;\n  const forceWrite = options.forceWrite !== undefined ? options.forceWrite : true;\n\n  // 在生产环境中，此函数不执行任何操作\n  if (_is_production) {\n    return;\n  }\n\n  // 确保日志目录已初始化\n  if (_temp_dir === null) {\n    _initialize_log_dirs();\n  }\n\n  const [main_log_dir, temp_log_dir] = _get_log_dirs();\n\n  // 检查文件名是否包含后缀，如果不包含则添加.txt后缀\n  if (!filename.includes(\".\")) {\n    filename = `${filename}.txt`;\n  }\n\n  // 根据clear_on_restart参数决定文件的存放位置和命名\n  let log_dir;\n  let log_file;\n  \n  if (clear_on_restart) {\n    // 非持久化文件，放在临时目录中\n    log_dir = temp_log_dir;\n    // 如果指定了folder，则在临时目录下创建相应的子文件夹\n    if (folder) {\n      log_dir = path.join(log_dir, folder);\n    }\n    log_file = path.join(log_dir, filename);\n  } else {\n    // 持久化文件，添加前缀并放在主目录中（不考虑folder参数）\n    log_dir = main_log_dir;\n    if (!filename.startsWith(\"persistent_\")) {\n      filename = `persistent_${filename}`;\n    }\n    log_file = path.join(log_dir, filename);\n  }\n\n  // 确保目录存在\n  if (!fs.existsSync(log_dir)) {\n    fs.mkdirSync(log_dir, { recursive: true });\n  }\n\n  // 处理不同类型的内容\n  let output;\n  if (typeof content === 'object') {\n    try {\n      // 尝试将内容格式化为JSON字符串\n      output = JSON.stringify(content, null, 2);\n    } catch {\n      // 如果无法转为JSON，则直接转为字符串\n      output = String(content);\n    }\n  } else {\n    output = String(content);\n  }\n\n  // 构建输出字符串\n  let formatted_output = \"\";\n\n  // 添加时间戳（如果需要）\n  if (show_timestamp) {\n    const now = new Date();\n    const timestamp = now.toISOString().replace('T', ' ').substring(0, 23);\n    formatted_output += `[${timestamp}]\\n`;\n  }\n\n  // 添加内容\n  formatted_output += output;\n\n  // 添加结尾的换行\n  formatted_output += '\\n'.repeat(line_breaks + 1);\n\n  // 根据参数和文件状态选择写入模式\n  // 1. 如果clear_on_restart=false，则始终使用追加模式\n  // 2. 如果clear_on_restart=true，则根据forceWrite和文件初始化情况决定\n  let write_mode = 'a';\n  if (clear_on_restart) {\n    if (\n      forceWrite ||\n      !fs.existsSync(log_file) ||\n      !logPro._initialized_files\n    ) {\n      write_mode = 'w';\n      // 创建已初始化文件集合（如果不存在）\n      if (!logPro._initialized_files) {\n        logPro._initialized_files = new Set();\n      }\n      // 记录此文件已被初始化\n      logPro._initialized_files.add(log_file);\n    }\n  }\n\n  // 写入文件\n  fs.writeFileSync(log_file, formatted_output, { encoding: 'utf-8', flag: write_mode });\n}\n\n/**\n * 将源目录中的所有文件移动到目标目录\n *\n * @param {string} source_dir 源目录路径\n * @param {string} target_dir 目标目录路径\n */\nfunction _migrate_files(source_dir, target_dir) {\n  if (_is_production || !fs.existsSync(source_dir)) {\n    return;\n  }\n\n  // 确保目标目录存在\n  if (!fs.existsSync(target_dir)) {\n    fs.mkdirSync(target_dir, { recursive: true });\n  }\n\n  // 首先清空目标目录中的非持久化文件（处理带时间戳文件名的情况）\n  if (fs.existsSync(target_dir)) {\n    fs.readdirSync(target_dir).forEach(item => {\n      // 保留持久化文件和临时目录\n      if (item.startsWith(\"persistent_\") || item.startsWith(\"temp_\")) {\n        return;\n      }\n\n      const target_path = path.join(target_dir, item);\n      try {\n        if (fs.statSync(target_path).isFile()) {\n          fs.unlinkSync(target_path);\n        } else if (fs.statSync(target_path).isDirectory()) {\n          fs.rmSync(target_path, { recursive: true, force: true });\n        }\n      } catch (e) {\n        console.error(`删除目标目录文件/文件夹 ${target_path} 时出错: ${e.message}`);\n      }\n    });\n  }\n\n  // 遍历源目录中的所有文件和子目录\n  fs.readdirSync(source_dir).forEach(item => {\n    const source_path = path.join(source_dir, item);\n    const target_path = path.join(target_dir, item);\n\n    if (fs.statSync(source_path).isFile()) {\n      // 如果目标目录已存在同名文件，先删除\n      if (fs.existsSync(target_path)) {\n        fs.unlinkSync(target_path);\n      }\n      // 移动文件\n      fs.renameSync(source_path, target_path);\n    } else if (fs.statSync(source_path).isDirectory()) {\n      // 如果是子目录，递归处理\n      _migrate_files(source_path, target_path);\n    }\n  });\n}\n\n/**\n * 清理指定目录中的所有非持久化文件\n *\n * @param {string} directory 要清理的目录路径\n */\nfunction _cleanup_non_persistent_files(directory) {\n  if (_is_production || !fs.existsSync(directory)) {\n    return;\n  }\n\n  fs.readdirSync(directory).forEach(item => {\n    // 跳过临时目录和持久化文件\n    if (item.startsWith(\"temp_\") || item.startsWith(\"persistent_\")) {\n      return;\n    }\n\n    const path_item = path.join(directory, item);\n    try {\n      if (fs.statSync(path_item).isFile()) {\n        fs.unlinkSync(path_item);\n      }\n    } catch (e) {\n      console.error(`删除文件 ${path_item} 时出错: ${e.message}`);\n    }\n  });\n}\n\n/**\n * 执行清理和迁移操作：\n * 1. 清理主目录中的非持久化文件\n * 2. 将临时目录中的文件移动到主目录\n * 3. 删除临时目录\n */\nfunction _cleanup() {\n  // 在生产环境中，不执行任何操作\n  if (_is_production) {\n    return;\n  }\n\n  // 如果临时目录未初始化，则无需清理\n  if (_temp_dir === null) {\n    return;\n  }\n\n  const [main_log_dir, temp_log_dir] = _get_log_dirs();\n\n  try {\n    // 1. 清理主目录中的非持久化文件\n    _cleanup_non_persistent_files(main_log_dir);\n\n    // 2. 将临时目录中的文件移动到主目录\n    _migrate_files(temp_log_dir, main_log_dir);\n\n    // 3. 删除临时目录\n    if (fs.existsSync(temp_log_dir)) {\n      fs.rmSync(temp_log_dir, { recursive: true, force: true });\n    }\n  } catch (e) {\n    console.error(`执行清理操作时出错: ${e.message}`);\n  }\n}\n\n/**\n * 清空logProLog目录下的文件\n *\n * @param {boolean} include_persistent 是否包括持久化文件，默认为false\n */\nfunction clearLogProLogs(include_persistent = false) {\n  // 在生产环境中，不执行任何操作\n  if (_is_production) {\n    return;\n  }\n\n  const [main_log_dir] = _get_log_dirs();\n\n  if (fs.existsSync(main_log_dir)) {\n    try {\n      if (include_persistent) {\n        // 如果包括持久化文件，则删除整个目录并重新创建\n        fs.rmSync(main_log_dir, { recursive: true, force: true });\n        fs.mkdirSync(main_log_dir, { recursive: true });\n      } else {\n        // 否则，只删除非持久化文件\n        fs.readdirSync(main_log_dir).forEach(item => {\n          // 跳过持久化文件\n          if (item.startsWith(\"persistent_\")) {\n            return;\n          }\n\n          const item_path = path.join(main_log_dir, item);\n          try {\n            if (fs.statSync(item_path).isFile()) {\n              fs.unlinkSync(item_path);\n            } else if (fs.statSync(item_path).isDirectory()) {\n              fs.rmSync(item_path, { recursive: true, force: true });\n            }\n          } catch (e) {\n            console.error(`清空logProLog目录时出错: ${e.message}`);\n          }\n        });\n      }\n    } catch (e) {\n      console.error(`清空logProLog目录时出错: ${e.message}`);\n    }\n  }\n}\n\n// 注册程序退出时的清理函数\nif (!_is_production) {\n  process.on('exit', _cleanup);\n  // 捕获意外终止信号\n  ['SIGINT', 'SIGTERM', 'SIGQUIT'].forEach(signal => {\n    process.on(signal, () => {\n      _cleanup();\n      process.exit(0);\n    });\n  });\n}\n\n// 在导入模块时初始化日志目录（非生产环境）\nif (!_is_production) {\n  _initialize_log_dirs();\n}\n\n// ES模块导出\nexport {\n  logPro,\n  clearLogProLogs,\n  _initialize_log_dirs,\n  _cleanup\n};\n\n// 默认导出\nexport default {\n  logPro,\n  clearLogProLogs,\n  _initialize_log_dirs,\n  _cleanup\n};\n"],"names":["_temp_dir","_is_production","process","env","NODE_ENV","_get_log_dirs","root_dir","cwd","main_log_dir","path","join","temp_dir_name","pid","_initialize_log_dirs","temp_log_dir","fs","existsSync","mkdirSync","recursive","temp_parent_dir","dirname","readdirSync","forEach","item","startsWith","statSync","isDirectory","pid_str","split","platform","execSync","kill","e","_pid_exists","parseInt","old_temp_dir","rmSync","force","console","error","message","logPro","content","options","filename","clear_on_restart","undefined","show_timestamp","line_breaks","folder","forceWrite","log_dir","log_file","output","includes","JSON","stringify","String","formatted_output","Date","toISOString","replace","substring","repeat","write_mode","_initialized_files","Set","add","writeFileSync","encoding","flag","_migrate_files","source_dir","target_dir","target_path","isFile","unlinkSync","source_path","renameSync","_cleanup","directory","path_item","clearLogProLogs","include_persistent","item_path","on","signal","exit","index_esm"],"mappings":"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"}