import t from"fs";import r from"path";import e from"process";import{execSync as i}from"child_process";let n=null;const s="production"===e.env.NODE_ENV;function c(){const t=e.cwd(),i=r.join(t,"logProLog"),n=`temp_${e.pid}`;return[i,r.join(i,n)]}function o(){if(s)return;const[o,a]=c();n=a,t.existsSync(o)||t.mkdirSync(o,{recursive:!0});const l=r.dirname(a);t.existsSync(l)&&t.readdirSync(l).forEach(n=>{if(n.startsWith("temp_")&&t.statSync(r.join(l,n)).isDirectory())try{const s=n.split("_")[1];if(!function(t){try{return"win32"===e.platform?(i(`tasklist /FI "PID eq ${t}" /NH`),!0):(e.kill(t,0),!0)}catch(t){return!1}}(parseInt(s))){const e=r.join(l,n);t.rmSync(e,{recursive:!0,force:!0})}}catch(t){console.error(`清理旧临时目录时出错: ${t.message}`)}}),t.existsSync(a)||t.mkdirSync(a,{recursive:!0})}function a(e,i={}){let l=i.filename||"default.txt";const y=void 0===i.clear_on_restart||i.clear_on_restart,f=i.show_timestamp||!1,S=void 0!==i.line_breaks?i.line_breaks:1,u=i.folder||null,d=void 0===i.forceWrite||i.forceWrite;if(s)return;null===n&&o();const[m,_]=c();let p,h,g;if(l.includes(".")||(l=`${l}.txt`),y?(p=_,u&&(p=r.join(p,u)),h=r.join(p,l)):(p=m,l.startsWith("persistent_")||(l=`persistent_${l}`),h=r.join(p,l)),t.existsSync(p)||t.mkdirSync(p,{recursive:!0}),"object"==typeof e)try{g=JSON.stringify(e,null,2)}catch{g=String(e)}else g=String(e);let x="";if(f){x+=`[${(new Date).toISOString().replace("T"," ").substring(0,23)}]\n`}x+=g,x+="\n".repeat(S+1);let v="a";y&&(!d&&t.existsSync(h)&&a._initialized_files||(v="w",a._initialized_files||(a._initialized_files=new Set),a._initialized_files.add(h))),t.writeFileSync(h,x,{encoding:"utf-8",flag:v})}function l(e,i){!s&&t.existsSync(e)&&(t.existsSync(i)||t.mkdirSync(i,{recursive:!0}),t.existsSync(i)&&t.readdirSync(i).forEach(e=>{if(e.startsWith("persistent_")||e.startsWith("temp_"))return;const n=r.join(i,e);try{t.statSync(n).isFile()?t.unlinkSync(n):t.statSync(n).isDirectory()&&t.rmSync(n,{recursive:!0,force:!0})}catch(t){console.error(`删除目标目录文件/文件夹 ${n} 时出错: ${t.message}`)}}),t.readdirSync(e).forEach(n=>{const s=r.join(e,n),c=r.join(i,n);t.statSync(s).isFile()?(t.existsSync(c)&&t.unlinkSync(c),t.renameSync(s,c)):t.statSync(s).isDirectory()&&l(s,c)}))}function y(){if(s)return;if(null===n)return;const[e,i]=c();try{o=e,!s&&t.existsSync(o)&&t.readdirSync(o).forEach(e=>{if(e.startsWith("temp_")||e.startsWith("persistent_"))return;const i=r.join(o,e);try{t.statSync(i).isFile()&&t.unlinkSync(i)}catch(t){console.error(`删除文件 ${i} 时出错: ${t.message}`)}}),l(i,e),t.existsSync(i)&&t.rmSync(i,{recursive:!0,force:!0})}catch(t){console.error(`执行清理操作时出错: ${t.message}`)}var o}function f(e=!1){if(s)return;const[i]=c();if(t.existsSync(i))try{e?(t.rmSync(i,{recursive:!0,force:!0}),t.mkdirSync(i,{recursive:!0})):t.readdirSync(i).forEach(e=>{if(e.startsWith("persistent_"))return;const n=r.join(i,e);try{t.statSync(n).isFile()?t.unlinkSync(n):t.statSync(n).isDirectory()&&t.rmSync(n,{recursive:!0,force:!0})}catch(t){console.error(`清空logProLog目录时出错: ${t.message}`)}})}catch(t){console.error(`清空logProLog目录时出错: ${t.message}`)}}s||(e.on("exit",y),["SIGINT","SIGTERM","SIGQUIT"].forEach(t=>{e.on(t,()=>{y(),e.exit(0)})})),s||o();var S={logPro:a,clearLogProLogs:f,_initialize_log_dirs:o,_cleanup:y};export{y as _cleanup,o as _initialize_log_dirs,f as clearLogProLogs,S as default,a as logPro};
//# sourceMappingURL=index.esm.mjs.map
